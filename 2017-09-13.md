# ES6中的常用特性和那些不常用但可能会非常有用的特性(Part 1)

## 写在前面：
去年刚进这家公司后就参与启动了DMP（Data-Management Platform）项目，项目从一开始就用的最新的技术，我也是从那时起开始大量接触ES6的语法，到目前为止已经一年多了。我发现ES6里的很多语法已经完全取代了老式的语法（比如有了const和let后就不会再用var，Promise和async/await完全取代了回调函数），然而还有一些特性，似乎完全没有用到。写这篇文章的目的，就是为了研究一下ES6里那些平时不怎么用的语法，是不是有可能在实际生产中会很有帮助。

## Part 1: 常用特性

1. const, let 
在只能用var来声明变量的时代，JavaScript是没有**块作用域**的，对于新手来说，用var来声明变量最常见的是这个问题：
```javascript
var a = []
for (var i = 0; i < 10; i++) {
  a[i] = function () {
    return i
  }
}
a[5]() // 期望的返回值是5，实际返回10

```
出现这种情况，是由于在**for**循环里声明的**i**其实是一个**全局变量**，数组里的每个函数都引用了这个变量**i**，由于**i**最后的值为10，所以不管你执行的是那个函数，最后都会返回10。 

如果用**let**就能避免这个问题
```javascript
let a = []
for(let i = 0; i < 10; i++) {
  a[i] = function () {
    return i
  }
}
a[5]()  // 与期望一致，返回值是5
```
那么问题来了，在**let**还没有出现之前，开发者是如何解决这个问题的呢？
可以用立即调用函数表达式（IIFE）:
```javascript
for(var i = 0; i < 10; i++) {
  a[i] = (function (x) {
    return function () {
      return x
    }
  })(i)
}
```
这样为什么行之有效，请参看《你不知道的JS 卷1》

使用**let**要注意的是，在代码块内JS引擎不会像对待**var**那样把声明提升，也就是说声明必须放在使用之前，否则会抛出**Uncaught ReferenceError**的错误。



关键字**const**则用于常量的声明，需要注意的是，const只对基本类型管用，对于对象这种就起不到约束作用了，比如
```javascript
const foo = { bar: 1 }
foo.bar = 2
console.log(foo) // { bar: 2 }
```
原因是const本质上只约束变量所指向的内存地址不变，对于基本类型，值就保存在变量指向的内存地址。


2. 函数参数默认值
这个不必多说，自从用上了这个特性，少写了很多代码，先看ES6怎么写
```javascript
function printX(x = 'x') {
  console.log(x)
}
printX() // x
printX('y')  // y
```
用法一目了然。
再来对比一下过去的写法：
```javascript
function printX(x) {
  x = x || 'x'
  console.log(x)
}
```
这还只是一个参数的情况，多个参数的情况下更能体现**函数参数默认值**的作用。

3. 箭头函数
箭头函数的意义，不只是写法更加优雅。
```javascript
// 箭头函数
var f = v => v
// 老式的写法
var f = function (v) {
  return v
}
```
多个参数
```javascript
// arrow function
var add = (num1, num2) => num1 + num2
// old style
var add = function (num1, num2) {
  return num1 + num2
}
```
简洁了不止一丢丢。

除了写法更英俊潇洒，还有**最关键**的一点区别，就是二者对**this**的处理方式，以下面这个例子来说：
```javascript {.line-numbers}
var a = 'foo'
function foo () {
  setTimeout(function () {
    console.log(this.a)
  }, 1000)
}
// 默认this绑定
foo() // foo
// 隐式this绑定
var obj = {
  a: 'bar',
  foo: foo
}
obj.foo() // foo
// 显式this绑定
foo.apply({ a: 'whatever' }) // foo
```
可以看到，无论何种方式，控制台输出始终是'foo'，也就是在一开始声明的全局变量**a**，说明**setTimeout**里的函数在执行时**this**指向全局对象window（浏览器环境下）。
如果把setTimeout里的函数换成箭头函数，再看看结果
```javascript
var a = 'foo'
function foo () {  
  setTimeout(() => {
    console.log(this.a)
  }, 1000)
}
foo() // foo
var obj = {
  a: 'bar',
  foo: foo
}
obj.foo()  // bar
foo.apply({ a: 'whatever' }) // whatever
```
产生差异的原因在于，箭头函数里的this**总是**指向定义时的上下文，而不是函数执行时的上下文。


4. 对象展开符(...)和属性简写 
这两个特性我个人非常喜欢，对象展开符可以用在许多地方
```javascript
let foo = {
  a: 1,
  b: 2,
  c: 3
}
// Example 0
// 以下两种方式效果相同
let bar = {...foo, d: 4}  // {a: 1, b: 2, c: 3, d: 4}
let baz = Object.assign({}, foo, { d: 4 })  // {a: 1, b: 2, c: 3, d: 4}
// Example 1
let { a, ...rest } = foo  // a => 1, rest => {b: 2, c: 3}
```

对象属性简写也很有用：
```javascript
let foo = 'foo'
let bar = 'bar'

let obj = {
  foo,
  bar
}
```
显而易见，声明对象时当key和value相同时，可以只写key而省略value部分。

5. async/await
关于async/await，有必要单独写一篇总结，这里先给自己挖个坑。

6. 新增内置函数
ES6 在String，Number，Array，Object这些原生对象上新增了很多实用方法，对于像lodash/underscore这类的类库依赖变小了很多。
#### String
includes, startsWith, endsWith, repeat, padStart, padEnd...
每个函数基本上看名字就知道是干啥的了。
```javascript
let name = 'wangweitao'
name.includes('wei') // true
name.startsWith('wang') // true
name.endsWith('ao') // true
name.repeat(2) // wangweitaowangweitao
// padStart, endStart的第一个参数指定字符串长度，当给定字符串小于这个长度时，用第二个参数来补齐
name.padStart(12, 'x') // xxwangweitao
name.padEnd(12, 'x')  // wangweitaoxx
```

#### Number
parseInt, parseFloat, isInteger, isNaN, EPSILON, **(Math.pow)...
parseInt, parseFloat之前是全局方法，可以直接调用，ES6以后移植到Number对象上，因此**不再是**全局的。
```javascript
Number.isInteger(3) // true
Number.isInteger(3.0) // true
Number.isInteger(3.3)  // false

Number.isNaN(NaN)  // 这个方法解决了JS里NaN == NaN为false的问题
```
Number.EPSILON表示一个极小常量，众所周知，由于浮点数的精度问题，大多数编程语言中 0.1 + 0.2 是不等于0.3的（在JS中等于0.30000000000000004），Number.EPSILON在判断浮点数是否相等时作用就体现出来了
```javascript
0.1 + 0.2 === 0.3  // false
(0.1 + 0.2) - 0.3 < Number.EPSILON  // true
0.3 - (0.1+ 0.2) < Number.EPSILON  // true
```

#### Array


#### Object


## Part 2: 不常用特性